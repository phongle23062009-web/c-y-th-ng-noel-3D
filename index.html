<!doctype html>
<html lang="vi">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Giáng Sinh 3D - Góc Nhìn Chuột</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #000;
            overflow: hidden
        }

        #app {
            width: 100vw;
            height: 100vh;
            display: block;
            position: relative
        }

        #overlay {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 18px;
            color: #ff5252;
            text-align: center;
            font-family: Arial, Helvetica, sans-serif
        }

        #overlay h1 {
            margin: 0;
            font-size: 22px
        }

        #overlay p {
            margin: 6px 0 0 0;
            font-size: 18px;
            color: #fff
        }

        .hint {
            color: #ffdede
        }

        canvas {
            display: block
        }
    </style>
</head>

<body>
    <div id="app"></div>
    <div id="overlay">
        <h1>GIỮ CHUỘT VÀ KÉO ĐỂ XOAY GÓC NHÌN!</h1>
        <p class="hint">Merry Christmas!</p>
    </div>

    <!-- three.js từ CDN (không cần build tool) -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

    <script>
        // Mô phỏng phiên bản turtle Python trong Web bằng three.js
        // - Góc nhìn xoay quanh trục Y bằng thao tác giữ chuột + kéo
        // - Cây dày lá dạng điểm, đèn nhấp nháy, hộp quà, cỗ xe và tuần lộc làm từ hộp
        // - Tuyết dạng điểm di chuyển xuống

        const WIDTH = window.innerWidth;
        const HEIGHT = window.innerHeight;

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0009);

        const camera = new THREE.PerspectiveCamera(50, WIDTH / HEIGHT, 1, 2000);
        const CAMERA_RADIUS = 700;
        let cameraAngle = 0; // degrees
        camera.position.set(CAMERA_RADIUS, 150, 0);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('app').appendChild(renderer.domElement);

        // Resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // --- Lights ---
        const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.9);
        scene.add(hemi);
        const dir = new THREE.DirectionalLight(0xffffff, 0.6);
        dir.position.set(100, 300, 100);
        scene.add(dir);

        // --- Ground (snow plane textured by simple material) ---
        const groundGeo = new THREE.PlaneGeometry(1600, 1600);
        const groundMat = new THREE.MeshPhongMaterial({ color: 0xf8fbff, shininess: 10 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -260;
        scene.add(ground);

        // Helper to create boxes (used for gifts, sleigh, reindeer)
        function makeBox(w, h, d, color) {
            const g = new THREE.BoxGeometry(w, h, d);
            const m = new THREE.MeshPhongMaterial({ color: color });
            return new THREE.Mesh(g, m);
        }

        // --- Cây dày (sử dụng Points) ---
        function createDenseTree() {
            const particleCount = 4200;
            const positions = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const colors = new Float32Array(particleCount * 3);

            const leafColors = [new THREE.Color('#004d00'), new THREE.Color('#0f5c26'), new THREE.Color('#166d30'), new THREE.Color('#228b22'), new THREE.Color('#32cd32')];

            let idx = 0;
            for (let i = 0; i < particleCount; i++) {
                // y within -200..200
                const y = -200 + Math.random() * 400;
                const progress = (y + 200) / 400;
                const maxRadius = 160 * (1 - progress);
                const r = Math.sqrt(Math.random()) * maxRadius;
                const angle = Math.random() * Math.PI * 2;
                const x = r * Math.cos(angle);
                const z = r * Math.sin(angle);

                positions[idx * 3 + 0] = x;
                positions[idx * 3 + 1] = y;
                positions[idx * 3 + 2] = z;

                const dist_ratio = r / (maxRadius + 0.1);
                let color;
                let size;
                if (dist_ratio < 0.4) { color = leafColors[0]; size = 18; }
                else if (dist_ratio < 0.7) { color = leafColors[1]; size = 12; }
                else { color = leafColors[Math.floor(2 + Math.random() * 3)]; size = 8; }

                colors[idx * 3 + 0] = color.r;
                colors[idx * 3 + 1] = color.g;
                colors[idx * 3 + 2] = color.b;

                sizes[idx] = size;
                idx++;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // Shader material to support per-point size & color
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: null },
                },
                vertexShader: `
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        void main(){
          vColor = customColor;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * (300.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
                fragmentShader: `
        varying vec3 vColor;
        void main(){
          float d = distance(gl_PointCoord, vec2(0.5));
          if(d > 0.5) discard;
          gl_FragColor = vec4(vColor, 1.0);
        }
      `,
                transparent: true
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);

            // Add lights (small spheres) scattered on tree for blinking
            const lightGroup = new THREE.Group();
            for (let i = 0; i < 80; i++) {
                const y = -200 + Math.random() * 420;
                const progress = (y + 200) / 400;
                const maxRadius = 160 * (1 - progress);
                const r = Math.sqrt(Math.random()) * maxRadius;
                const angle = Math.random() * Math.PI * 2;
                const x = r * Math.cos(angle);
                const z = r * Math.sin(angle);

                const col = new THREE.Color(Math.random() < 0.5 ? 0xff0000 : (Math.random() < 0.5 ? 0xffd700 : 0x00ffff));
                const g = new THREE.Mesh(new THREE.SphereGeometry(4, 8, 8), new THREE.MeshBasicMaterial({ color: col }));
                g.position.set(x, y, z);
                g.userData.baseColor = col;
                lightGroup.add(g);
            }
            scene.add(lightGroup);

            // Star on top
            const star = makeBox(12, 12, 2, 0xFFD700);
            star.position.set(0, 215, 0);
            scene.add(star);

            return { points, lightGroup };
        }

        const tree = createDenseTree();

        // --- Gifts under tree ---
        function createGift(x, y, z, size, color, ribbonColor) {
            const g = makeBox(size, size, size, color);
            g.position.set(x, y, z);
            scene.add(g);

            const ribbon1 = makeBox(size * 0.25, size + 1, size + 1, ribbonColor);
            ribbon1.position.set(x, y, z);
            scene.add(ribbon1);
            const ribbon2 = makeBox(size + 1, size * 0.25, size + 1, ribbonColor);
            ribbon2.position.set(x, y, z);
            scene.add(ribbon2);
        }

        createGift(90, -220, 90, 50, 0xb71c1c, 0xFFD700);
        createGift(-100, -230, 50, 45, 0x0d47a1, 0xC0C0C0);
        createGift(40, -225, -100, 40, 0x1b5e20, 0xff0000);

        // --- Sleigh + reindeer simplified ---
        function createSleigh(x, y, z, scale) {
            const group = new THREE.Group();
            const GREEN = 0x1B5E20, GOLD = 0xFFD700, WOOD = 0x795548;

            const body = makeBox(50 * scale, 30 * scale, 35 * scale, GREEN);
            body.position.set(x - 40 * scale + 5 * scale, y - 10 * scale + 10 * scale, z);
            group.add(body);

            // runners
            const runner1 = makeBox(60 * scale, 5 * scale, 5 * scale, WOOD);
            runner1.position.set(x - 40 * scale, y - 10 * scale - 15 * scale, z + 15 * scale);
            group.add(runner1);
            const runner3 = runner1.clone(); runner3.position.set(x - 40 * scale, y - 10 * scale - 15 * scale, z - 15 * scale); group.add(runner3);

            // cargo
            const bag = makeBox(20 * scale, 25 * scale, 30 * scale, WOOD);
            bag.position.set(x - 40 * scale - 25 * scale, y - 10 * scale + 15 * scale, z);
            group.add(bag);

            // small gift top
            const gift = makeBox(10 * scale, 10 * scale, 10 * scale, 0xff0000);
            gift.position.set(x - 40 * scale - 25 * scale, y - 10 * scale + 35 * scale, z);
            group.add(gift);

            // two reindeers (boxes with antler sticks)
            for (let i = 0; i < 2; i++) {
                const rz = (i === 0) ? -20 * scale : 20 * scale;
                const r = new THREE.Group();
                const bodyr = makeBox(30 * scale, 20 * scale, 15 * scale, 0x8D6E63);
                bodyr.position.set(x + 80 * scale, y, z + rz);
                r.add(bodyr);
                const head = makeBox(12 * scale, 12 * scale, 12 * scale, 0x8D6E63);
                head.position.set(x + 80 * scale + 20 * scale, y + 15 * scale, z + rz);
                r.add(head);
                // antler simple
                const ant = makeBox(4 * scale, 20 * scale, 4 * scale, 0x5D4037);
                ant.position.set(x + 80 * scale + 6 * scale, y + 6 * scale, z + rz);
                r.add(ant);
                scene.add(r);
            }

            scene.add(group);
        }

        createSleigh(350, -180, 0, 3);

        // --- Snowflakes (2D-like points falling) ---
        const snowCount = 200;
        const snowPositions = new Float32Array(snowCount * 3);
        const snowSpeeds = new Float32Array(snowCount);
        for (let i = 0; i < snowCount; i++) {
            snowPositions[i * 3 + 0] = (Math.random() - 0.5) * 800;
            snowPositions[i * 3 + 1] = (Math.random() - 0.5) * 700;
            snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 800;
            snowSpeeds[i] = 0.6 + Math.random() * 2.5;
        }
        const snowGeo = new THREE.BufferGeometry();
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
        const snowMat = new THREE.PointsMaterial({ size: 4, color: 0xffffff, transparent: true, opacity: 0.9 });
        const snowPoints = new THREE.Points(snowGeo, snowMat);
        scene.add(snowPoints);

        // --- Mouse drag to rotate camera around Y ---
        let dragging = false, lastX = 0;
        const appElem = renderer.domElement;
        appElem.style.touchAction = 'none';

        appElem.addEventListener('pointerdown', (e) => { dragging = true; lastX = e.clientX; });
        window.addEventListener('pointerup', () => { dragging = false; });
        appElem.addEventListener('pointermove', (e) => {
            if (!dragging) return;
            const dx = e.clientX - lastX;
            cameraAngle += dx * 0.3; // sensitivity like turtle
            lastX = e.clientX;
        });

        // --- Animation ---
        const clock = new THREE.Clock();
        function animate() {
            const t = clock.getElapsedTime();

            // update camera position on a fixed radius using cameraAngle
            const rad = THREE.MathUtils.degToRad(cameraAngle);
            camera.position.x = Math.cos(rad) * CAMERA_RADIUS;
            camera.position.z = Math.sin(rad) * CAMERA_RADIUS;
            camera.lookAt(0, 30, 0);

            // blink tree lights randomly
            tree.lightGroup.children.forEach((l, i) => {
                const flick = Math.sin(t * 5 + i) > 0.7 ? 1.0 : (Math.random() < 0.02 ? 1.0 : 0.2);
                l.material.opacity = flick;
                l.material.transparent = true;
            });

            // snow falling
            const pos = snowGeo.attributes.position.array;
            for (let i = 0; i < snowCount; i++) {
                pos[i * 3 + 1] -= snowSpeeds[i];
                if (pos[i * 3 + 1] < -350) pos[i * 3 + 1] = 350;
            }
            snowGeo.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

    </script>
</body>

</html>